#! /usr/bin/env ruby

def levenshtein(s, t)
  len1 = s.length
  len2 = t.length

  return len2 if len1 == 0
  return len1 if len2 == 0
  if s[-1] == t[-1]
    cost = 0
  else
    cost = 1
  end
  [
    levenshtein(s[0...-1], t) + 1,
    levenshtein(s, t[0...-1]) + 1,
    levenshtein(s[0...-1], t[0...-1]) + cost
    ].min
end

@memo = Hash.new

def levenshteinPrime(s, t)
  levenshteinMemo(s, 0, s.length, t, 0, t.length)
end

def levenshteinMemo(s, i, len1, t, j, len2)
  key = [i,len1,j,len2].join(',')
  return @memo[key] if @memo.has_key?(key)

  return len2 if len1 == 0
  return len1 if len2 == 0
  cost = 0
  if s[i] != t[j]
    cost = 1
  end

  dist = [
    levenshteinMemo(s, i+1,len1-1, t,j,len2)+1,
    levenshteinMemo(s,i,len1,t,j+1,len2-1)+1,
    levenshteinMemo(s,i+1,len1-1,t,j+1,len2-1)+cost
    ].min
  @memo[key] = dist;
  return dist;
end

def time
  start = Time.now
  yield
  puts Time.now - start
end

time do
  puts "Levenshtein distance between '#{ARGV[0]}' and '#{ARGV[1]}' is #{levenshtein(ARGV[0], ARGV[1])}"
end
time do
  puts "Levenshtein (memoization)"
  levenshteinPrime(ARGV[0], ARGV[1])
end
